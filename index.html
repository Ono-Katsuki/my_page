<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>バランス調整された点群による惑星系</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const objects = [];
        let formationState = 0; // 0: DNA, 1: 単一球体, 2: 惑星系

        function createObject(geometry, initialAngle, yOffset, strand) {
            const shade = Math.random() * 0.7 + 0.3;
            const color = strand === 0 ? new THREE.Color(shade, shade * 0.5, shade * 0.5) : new THREE.Color(shade * 0.5, shade, shade * 0.5);
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                wireframe: true,
                transparent: true,
                opacity: Math.random() * 0.5 + 0.5
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            return {
                mesh: mesh,
                initialAngle: initialAngle,
                yOffset: yOffset,
                strand: strand,
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.2,
                    y: (Math.random() - 0.5) * 0.2,
                    z: (Math.random() - 0.5) * 0.2
                },
                scaleSpeed: Math.random() * 0.03 + 0.01,
                scaleDirection: 1,
                singleSpherePosition: new THREE.Vector3(),
                planetPosition: new THREE.Vector3(),
                dnaPosition: new THREE.Vector3(),
                orbitRadius: 0,
                orbitSpeed: 0,
                planetType: 'particle' // 'core', 'planet', 'particle'
            };
        }

        function init() {
            const geometries = [
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.ConeGeometry(0.3, 0.5, 32),
                new THREE.TorusGeometry(0.3, 0.2, 16, 100),
                new THREE.TetrahedronGeometry(0.4)
            ];

            const dnaLength = 200;
            const objectsPerTurn = 20;
            const turnsCount = 20;

            for (let strand = 0; strand < 2; strand++) {
                for (let i = 0; i < dnaLength; i++) {
                    const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                    const initialAngle = (i % objectsPerTurn) * (Math.PI * 2 / objectsPerTurn) + (strand * Math.PI);
                    const yOffset = (i / objectsPerTurn) * (turnsCount / dnaLength) * 200 - 100;
                    objects.push(createObject(geometry, initialAngle, yOffset, strand));
                }
            }

            const planetCount = 5;
            const coreSize = 8; // 中心球体のサイズを縮小
            let planetIndex = 0;

            objects.forEach((obj, index) => {
                // 単一球体の位置
                const phi = Math.acos(-1 + (2 * index) / objects.length);
                const theta = Math.sqrt(objects.length * Math.PI) * phi;
                const x = 50 * Math.cos(theta) * Math.sin(phi);
                const y = 50 * Math.sin(theta) * Math.sin(phi);
                const z = 50 * Math.cos(phi);
                obj.singleSpherePosition.set(x, y, z);

                // 惑星系の位置
                if (index < objects.length * 0.1) { // 中心球体の粒子数を減らす
                    // 中心の球体を構成する粒子
                    const coreAngle = Math.random() * Math.PI * 2;
                    const coreRadius = Math.random() * coreSize;
                    const coreY = (Math.random() - 0.5) * coreSize;
                    obj.planetPosition.set(
                        Math.cos(coreAngle) * coreRadius,
                        coreY,
                        Math.sin(coreAngle) * coreRadius
                    );
                    obj.orbitSpeed = 0.2 + Math.random() * 0.1;
                    obj.planetType = 'core';
                    obj.mesh.scale.setScalar(1.5); // 中心球体の粒子サイズを調整
                } else if (index % Math.floor(objects.length / planetCount) === 0) {
                    // 惑星
                    planetIndex++;
                    obj.orbitRadius = 20 + planetIndex * 12;
                    obj.orbitSpeed = 0.3 / planetIndex;
                    obj.planetType = 'planet';
                    obj.mesh.scale.setScalar(2 + Math.random()); // 惑星のサイズを大きく
                } else {
                    // 惑星の周りの小さな物体
                    const nearestPlanetIndex = Math.floor(index / (objects.length / planetCount)) * (objects.length / planetCount);
                    const nearestPlanet = objects[nearestPlanetIndex];
                    obj.orbitRadius = 3 + Math.random() * 5;
                    obj.orbitSpeed = 0.1 + Math.random() * 0.2;
                    obj.planetPosition.copy(nearestPlanet.planetPosition);
                    obj.planetType = 'particle';
                    obj.mesh.scale.setScalar(0.8 + Math.random() * 0.4); // 粒子のサイズを調整
                }

                // DNA位置
                const radius = 10;
                const xPos = Math.cos(obj.initialAngle) * radius;
                const zPos = Math.sin(obj.initialAngle) * radius;
                obj.dnaPosition.set(xPos, obj.yOffset, zPos);
            });

            animate();
        }

        camera.position.set(0, 0, 150);
        camera.lookAt(scene.position);

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            objects.forEach((obj, index) => {
                obj.mesh.rotation.x += obj.rotationSpeed.x;
                obj.mesh.rotation.y += obj.rotationSpeed.y;
                obj.mesh.rotation.z += obj.rotationSpeed.z;

                let targetPosition;
                switch (formationState) {
                    case 0: // DNA
                        targetPosition = new THREE.Vector3(
                            obj.dnaPosition.x,
                            obj.dnaPosition.y + Math.sin(time * 2 + index * 0.1) * 0.5,
                            obj.dnaPosition.z
                        );
                        break;
                    case 1: // 単一球体
                        targetPosition = obj.singleSpherePosition;
                        break;
                    case 2: // 惑星系
                        if (obj.planetType === 'core') {
                            // 中心球体の粒子
                            const angle = time * obj.orbitSpeed;
                            targetPosition = new THREE.Vector3(
                                Math.cos(angle) * obj.planetPosition.x - Math.sin(angle) * obj.planetPosition.z,
                                obj.planetPosition.y,
                                Math.sin(angle) * obj.planetPosition.x + Math.cos(angle) * obj.planetPosition.z
                            );
                        } else if (obj.planetType === 'planet') {
                            // 惑星の公転
                            const angle = time * obj.orbitSpeed;
                            targetPosition = new THREE.Vector3(
                                Math.cos(angle) * obj.orbitRadius,
                                Math.sin(angle) * obj.orbitRadius * 0.3,
                                Math.sin(angle) * obj.orbitRadius
                            );
                        } else {
                            // 惑星の周りの物体
                            const parentPlanet = objects.find(o => o.planetType === 'planet' && o.orbitRadius < obj.orbitRadius);
                            if (parentPlanet) {
                                const parentPosition = parentPlanet.mesh.position;
                                const angle = time * obj.orbitSpeed;
                                targetPosition = new THREE.Vector3(
                                    parentPosition.x + Math.cos(angle) * obj.orbitRadius,
                                    parentPosition.y + Math.sin(angle) * obj.orbitRadius * 0.3,
                                    parentPosition.z + Math.sin(angle) * obj.orbitRadius
                                );
                            } else {
                                targetPosition = obj.planetPosition;
                            }
                        }
                        break;
                }

                obj.mesh.position.lerp(targetPosition, 0.05);

                if (formationState !== 2) {
                    obj.mesh.scale.addScalar(obj.scaleSpeed * obj.scaleDirection);
                    if (obj.mesh.scale.x > 1.3 || obj.mesh.scale.x < 0.7) {
                        obj.scaleDirection *= -1;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('click', () => {
            formationState = (formationState + 1) % 3;
        });

        init();
    </script>
</body>
</html>
